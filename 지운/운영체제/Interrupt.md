# Interrupt


## 목차
1. 개념
2. 종류
3. 우선순위
4. 구성 요소
5. 동작 원리

---

## 1. 개념
- `Interrupt (인터럽트)` : CPU가 프로그램 실행 중에 예외상황이 발생, 처리가 필요한 경우 현재 실행 중인 작업을 일시중단하고 **발생한 상황을 먼저 처리**한 뒤, 다시 실행 중인 작업을 진행
- 일반적으로 I/O(입출력) 연산이 CPU 연산 속도보다 느리므로, I/O 연산이 끝난 뒤 인터럽트를 이용해 CPU에게 알리면 CPU가 해당 연산 결과를 이용해 작업을 완료하는 방식으로 사용

## 2. 종류
### 외부 인터럽트 (하드웨어 인터럽트)
- `전원 이상 인터럽트` : 정전, 전력 이상 등
- `기계 착오 인터럽트` : CPU 기능 오류
- `외부 신호 인터럽트`
  - `타이머에 의한 인터럽트` : 자원의 할당 시간이 종료되는 경우<br>
    예) preemptive scheduling
  - `키보드에 의한 인터럽트` : Ctrl+Alt+Del
  - `외부장치에 의한 인터럽트` : 스위치 등의 트리거 실행으로 인한 인터럽트 요청
- `입출력 인터럽트`
  - 입출력 장치가 데이터 전송을 요구할 때
  - 입출력이 종료되어 다음 동작을 수행해야 할 때
  - 입출력 데이터에 이상이 있을 때
### 내부 인터럽트 (소프트웨어 인터럽트)
- `내부 인터럽트 = 트랩 (Trap)` : 잘못된 명령 또는 데이터 사용 시 발생
- `프로그램 검사 인터럽트`
  - Division by zero
  - Overflow / Underflow
  - 그 외 Exception
- `SVC (SuperVisor Call) 인터럽트`
  - 사용자가 프로그램을 실행시키거나 감시프로그램 호출하는 등, 운영체제를 호출해서 처리할 때<br>
    예) 사용자 프로그램에서 `open("a.txt")` 명령어가 존재 시, 프로그램에서 처리할 수 없는 OS 내부 정의 코드이므로 인터럽트 후 커널 모드로 전환 필요
  - 소프트웨어 이용 중 다른 프로세스 실행 시 시분할 처리를 위해 자원 할당 수행

## 3. 우선순위
### 우선순위
> 1. 전원 이상(Power Fail)<br>
> 2. 기계 착오(Machine Check)<br>
> 3. 외부 신호(External)<br>
> 4. 입출력(I/O)<br>
> 5. 명령어 이상<br>
> 6. 프로그램 검사(Program Check)<br>
> 7. SVC(SuperVisor Call)<br>

### 우선순위 판별법
- `Polling (소프트웨어적 방법)` : 인터럽트 요청 플래그를 차례로 비교, 우선순위가 가장 높은 인터럽트 자원에 해당하는 서비스 루틴 수행
  - 속도가 빠른 장치에 높은 등급 부여
  - 우선순위 변경 용이
  - 인터럽트가 많을수록 하드웨어적 방법 대비 우선순위 판단 속도 저하
- `Interrupt (하드웨어적 방법)`
  : MCU (Micro Controller Unit)이 **자체 하드웨어적으로 변화 감지**, 변화 시에만 일정 동작 수행
    인터럽트 요청 장치와 CPU 간 장치번호를 식별할 수 있는 버스 (Bus)를 직/병렬로 연결하여 사용
  - `Daisy Chain`
    - 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결
    - 우선순위가 높은 장치부터 상위에 차례로 배치
  - `병렬 우선순위 부여`
    - 각 장치별 우선순위 판별을 위한 Mask Register에 bit 설정
    - 우선순위가 높은 서비스 루틴 수행 중 우선순위가 낮은 bit 비활성화 가능
    - 우선순위가 높은 인터럽트는 낮은 인터럽트 수행 중에도 우선 처리

## 4. 구성 요소
- `발생원 (Source)` : 인터럽트 요청 대상
- `우선순위 (Priority)` : 복수 요청 시 어떤 서비스를 먼저 수행할 지
- `인터럽트 벡터 (Interrupt Vector)` : 서비스 루틴의 시작 번지
### Interrupt Vector
- 인터럽트 발생 시 해야 할 일을 정해놓은 것, ISR (인터럽트 서비스 루틴)의 시작 주소
### IDT (Interrupt Descriptor=Vector Table)
- 미리 정의되어 있는 인터럽트들의 번호 및 실행 코드를 가리키는 주소들이 저장된 테이블
- 동작 순서
  1. 컴퓨터 부팅 시 OS가 IDT에 인터럽트 기록
  2. 인터럽트 발생 시 IDT 확인 후 인터럽트 번호에 해당하는 함수를 호출해 처리
### ISR (Interrupt Service Routine)
- 인터럽트 발생 시 어떤 동작을 할지 정해져 있는 OS 내부 실행 코드
### IRET (Interrupt RETurn)
- 이전 태스크로 다시 돌아가도록 하는 어셈블리 명령어
- ISR의 마지막 명령어
### Interrupt Handler
- 인터럽트를 핸들링(처리)하기 위한 함수
- 함수 형태로 존재, 커널 내부의 IRQ(Interrupt ReQuest) 서브 시스템을 통해 호출
- 최소 요구 조건 : 인터럽트를 받았다는 사실을 인터럽트를 발생시킨 하드웨어에 알려야 함
### Interrupt Context
- 현재 실행 중인 프로세스가 인터럽트를 처리 중인 것을 의미

## 5. 동작 원리
![인터럽트 순서](https://velog.velcdn.com/images/jiun2577/post/f6c4e920-ec00-4903-8f8a-ea2dc8af6d93/image.png)
> 1. Process A가 system call을 통해 인터럽트 발생<br>
> 2. CPU는 현재 진행 중인 명령어 완료 후 인터럽트 신호 확인<br>
> 3. 진행중인 상태를 해당 프로세스의 PCB (Process Control Block)에 저장 ([PCB 정의](https://github.com/CS-Algorithm-Study/CS/blob/main/%EC%A7%80%EC%9A%B4/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/Process%26Thread.md#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD))<br>
> 4. PC (Program Counter)에 다음 실행할 명령의 주소 저장<br>
> 5. 발생한 인터럽트 번호를 IDT에서 확인, ISR 주소값을 얻은 뒤 ISR로 점프<br>
> 6. 서비스 루틴 실행<br>
> 7. 완료 후, 원래의 레지스터 복원<br>
> 8. ISR 끝에 존재하는 IRET 명령어에 의해 인터럽트 해제<br>
> 9. IRET 명령어 실행 뒤, 원래의 PC 값을 복원해 이전 실행 위치로 복원<br>
