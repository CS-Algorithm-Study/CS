# Thrashing


## 목차
1. 개념
2. 정적 할당
3. 동적 할당

---

## 1. 개념
- **`Thrashing(스레싱)`** : 멀티프로그래밍 정도가 너무 높을 때 발생하는 현상
  > 메모리가 꽉 찬 뒤에 새로운 프로그램을 메모리에 올릴 때에는, **기존 프로그램을 스왑 영역으로 옮기는 횟수 증가**<br>
  > 따라서 하드디스크의 입출력이 너무 많아 **페이지의 잦은 부재**로 작업이 멈춘 것처럼 보이는 현상<br>
- **`멀티프로그래밍 정도`** : 동시에 실행하는 프로그램의 수
  ![멀티프로그래밍 정도와 CPU 사용률](https://velog.velcdn.com/images/chappi/post/860b35c8-dc1a-4ee1-b228-48e3da231e77/image.png)
  - 멀티프로그래밍 정도와 CPU 사용률의 관계
  - **`Thrashing point`** : 메모리가 꽉 차서 CPU가 스왑 영역으로 기존 페이지를 보내고 새로운 페이지를 메모리에 가져오는 작업이 잦아지는 시점

### 해결책
- `물리 메모리 용량 증가` : 물리 메모리를 늘리면 CPU의 사용률도 높아지고 Thrashing point가 늦춰지므로 컴퓨터 성능 향상
  > But! 물리 메모리의 용량이 충분한 크기에 도달하면, 그 뒤에 용량을 더 늘려도 작업 속도에는 영향 X<br>
  > `충분한 크기` : CPU가 한번에 처리하는 양보다 메모리의 크기가 더 큰 시점
- `프레임 할당 정책` : 실행 중인 여러 프로세스에 프레임(메모리 크기)을 나누는 기준에 따라 시스템 성능 결정
  > 어떤 프로세스에 너무 적은 프레임을 할당 → Page fault(페이지 부재) 자주 발생<br>
  > 어떤 프로세스에 너무 많은 프레임을 할당 → 불필요한 메모리가 낭비되어 전반적인 시스템 성능 저하<br>
  > 적절히 나누어주는 정책 필요 → `정적 할당`, `동적 할당`

## 2. 정적 할당
- `정적 할당` : 프로세스 실행 초기에 프레임을 나누어준 뒤 크기 고정
### 균등 할당 방식
  ![균등 할당 방식](https://github.com/CS-Algorithm-Study/CS/assets/90232934/3eee1c82-30e9-4d87-a910-4af0c44eef73)
  - 프로세스의 크기와 상관없이, 사용 가능한 프레임을 모든 프로세스에 균등하게 할당
  > Page fault와 시스템 성능 저하 문제가 모두 발생

### 비례 할당 방식
  ![비례 할당 방식](https://velog.velcdn.com/images/chappi/post/ee0ec64f-81ec-4719-a037-bd751d58be23/image.png)
  - 프로세스의 **크기에 비례**해, 사용 가능한 프레임을 할당
  - 균등 할당 방식보다 비교적 현실적인 방식
  > **프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영 X**<br>
  > (예. 동영상 플레이어는 프로그램 자체의 크기는 작으나 실행 중에는 영상의 크기가 커서 더 많은 메모리 필요)<br>
  > **당장 사용하지 않더라도 메모리를 처음부터 할당해놓으므로 공간 낭비 발생**<br>
  > (예. 처음부터 할당된 모든 메모리를 쓰지 않고 적은 양만 쓰는 큰 프로세스)

## 3. 동적 할당
- `동적 할당` : 시시각각 요청이 변함에 따라 프레임을 유동적으로 할당
### 작업 집합 모델(Working set model)
  ![작업 집합 모델](https://velog.velcdn.com/images/chappi/post/fcaf9bab-e340-4801-872f-65451da3d52a/image.png)
  - **가장 최근에 접근한 프레임이 이후에도 또 참조될 가능성이 높다**고 가정
  - 최근 일정 시간동안 참조된 페이지를 집합으로 만든 뒤, 이 **집합에 속한 페이지는 물리 메모리에 유지**해 프로세스 실행
  - `작업 집합 크기(Working set size)` : 작업 집합에 들어갈 최대 페이지 수, 동시에 작업 집합 갱신 단위
  - `작업 집합 윈도우(Working set window)` : 현 시점에서 살펴볼 최대 페이지의 범위
  - 위와 아래 예시에서 작업 집합 크기 = 5, 작업 집합 윈도우 = 10으로 정한 상황
  ![작업 집합 모델2](https://velog.velcdn.com/images/chappi/post/fcaf9bab-e340-4801-872f-65451da3d52a/image.png)
    - WS(t1) = {1, 7, 5, 2, 3}
    - WS(t2) = {2, 3, 4, 1, 7} (실제로 5번 페이지도 존재하지만, 작업 집합 크기를 초과했고 t2 시점에서 가장 먼 페이지이므로 제외
    - WS(t3) = {5, 3, 2, 4}
  > 작업 집합 윈도우를 너무 작게 잡으면 필요한 페이지도 스왑 영역으로 넘어가버림<br>
  > 작업 집합 윈도우를 너무 크게 잡으면 필요없는 페이지가 메모리에 남게 됨<br>
  > **작업 집합 모델 사용 시, 어떤 프레임을 가져올지는 알지만 할당해야 할 프레임의 양은 모르**는 문제 존재<br>
  > 즉 프로세스의 성능을 높일 수는 있으나 스레싱 문제를 근본적으로 해결하는 수단은 못됨

### 페이지 부재 빈도(Page fault Frequency, PFF)
  ![페이지 부재 빈도](https://velog.velcdn.com/images/chappi/post/71754045-7bc0-40a6-adb5-f57466735358/image.png)
  - 페이지 부재 횟수를 통해 부재 비율을 계산
  - 페이지 부재 비율이 상한선 초과 → 할당한 프레임이 적어서 발생하는 것이므로 프레임 추가 할당
  - 페이지 부재 비율이 하한선 미만 → 할당한 프레임이 많아서 발생하는 것이므로 프레임 회수
  > 그림에서, upper bound와 lower bound 사이에 존재할 때 이상적인 안정기<br>
  > 프로세스가 실행되는 동안에도 지속적으로 페이지 할당, 회수를 진행해 적절한 페이지 할당량을 조절
