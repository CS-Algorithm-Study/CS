# Process & Thread


## 목차
1. 개념
2. 자원 공유
3. 동시 실행의 원리
4. 프로세스 생명 주기
5. 스레드 생명 주기

---

## 1. 개념
- `프로그램` : 컴퓨터에서 실행할 수 있으나 **실행되지 않은 상태**의 모든 파일(=정적 프로그램, Static Program)
- **`프로세스`** : 운영체제로부터 자원을 할당받은 **작업의 단위**. 즉 컴퓨터에서 현재 작업중인, **동적인 프로그램**을 의미
- **`스레드`** : 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**. 프로세스 안에서 여러 스레드가 동시에 동작할 수 있다(멀티 스레드).

## 2. 자원 공유
### 프로세스의 자원 구조
  ![프로세스의 자원 구조](https://t1.daumcdn.net/cfile/tistory/114A773E511554972A)
  - `코드 영역(Code)` : CPU가 해석 가능한 기계어 형태로 저장된 프로그램 코드
  - `데이터 영역(Data)` : 코드가 실행되면서 사용되는 전역 변수 및 데이터들. 아래의 3개 영역으로 세분화
  	- .bss : 초기값이 없는 전역 변수, static 변수 저장
   	- .rodata : 상수 키워드 선언된 변수, 문자열 상수 저장
    - .data : 전역 변수, static 변수 등 프로그램이 사용하는 데이터 저장
  - `힙 영역(Heap)` : 생성자, 인스턴스 등 동적으로 할당되는 데이터. 사용자에 의해 메모리 공간의 동적 할당 및 해제가 이루어짐
  - `스택 영역(Stack)` : 지역 변수와 같은 호출된 함수가 종료 시 되돌아올 임시적인 자료를 저장. 함수의 호출 시 할당, 함수 실행 완료 시 소멸, stack 영역 초과 시 **Error(Stack Overflow)** 발생
> 정적 영역 : 코드 영역, 데이터 영역<br>
> 동적 영역 : 힙 영역, 스택 영역

### 스레드의 자원 공유
  ![스레드의 자원 공유](https://t1.daumcdn.net/cfile/tistory/9984B34E5C98844501)
  - 스레드는 프로세스의 4가지 메모리 영역 중 Stack 영역을 할당받아 복사, 나머지 영역은 프로세스 내 다른 스레드들과 **공유**
  - 스레드는 **독립적인 스택**을 가짐
  → 스레드는 **독립적인 함수 호출**이 가능함
  → 스레드는 **독립적인 실행 흐름**을 가질 수 있음
  > ∴ 하나의 프로세스를 다수의 실행 단위인 스레드로 분리
  → **자원의 생성 및 관리의 중복을 최소화**

### 프로세스의 자원 공유
- `IPC(Inter-Process Communication)` : 한 OS 내에서 프로세스 간의 통신. Shared Memory, Message Passing 2개의 모델 존재
- `LPC(Local inter-Process Communication)` : 경량 프로세스 간의 통신, 커널에서만 제공됨
> 프로세스의 자원 공유는 RAM과 CPU 사이의 캐시 메모리까지 초기화됨 → 자원 부담 증대<br>
> ∴ 다중 작업 방식 : **다중 스레딩**이 다중 프로세싱보다 효율적
<br>

> 원칙적으로 프로세스 간의 자원 공유는 매우 위험하므로 금지되어 있음<br>
> 부모, 자식 프로세스 간 병렬 처리를 통한 빠른 실행, 중요 프로세스의 안정성, 성능 최적화 정도의 이유로 제한적으로 사용됨

## 3. 동시 실행의 원리(Multi Tasking)
### CPU의 멀티코어, 스레드 개념
- `코어` : 하드웨어의 관점에서 시스템의 모든 연산을 처리하는 CPU의 중심부, 코어의 수와 CPU의 성능은 비례
- `스레드` : 소프트웨어의 관점에서 논리적인 작업을 나누어 처리하는 단위(≠ 프로세스 상의 스레드)
예) 4코어 8스레드 = 하나의 물리적 코어가 2개 이상의 스레드를 동시에 실행 가능 = CPU가 8개의 작업을 동시에 처리 가능
- `하이퍼스레딩` : 한 개의 코어를 논리적으로 반으로 분리해 작업 처리량을 늘리는 기술(1코어 2스레드)
### CPU의 작업 처리 방식
|  | `동시성` | `병렬성` |
|:---:|:---:|:---:|
| 개념 | 논리적인 개념 | 물리적인 개념 |
| 의미 | **동시에 실행되는 것처럼 보이게 함** | **실제로 동시에 여러 작업이 처리됨** |
| 동작 방식 | 싱글 코어에서 멀티 스레드의 동작(Context Switch) | 멀티 코어에서 멀티 스레드의 동작 |
| 처리 양 | 한번에 많은 **분할된** 작업 처리 | 한번에 많은 작업 처리 |

![동시성과 병렬성](https://t1.daumcdn.net/cfile/tistory/995359405FBBB9591C)

- 동시성의 필요 근거
  - `하드웨어적 한계` : 발열 등의 이슈로 인해 CPU 단일 코어의 성능 개선, 코어의 수 증폭에 대한 하드웨어적인 한계 존재
  - `논리적 효율성` : 가령 작업 시간이 긴 작업과 짧은 작업이 있다면, 동시성을 이용하지 않을 경우 최악의 경우 **작업 시간이 짧은 작업이 다른 작업이 끝날 때까지 기다려야 함**

> `Context Switch` : 동시성 개념에서, 여러 작업이 동시에 돌아가는 것처럼 보이게 하기 위해 **작업들을 잘게 나누어 각 작업의 부분을 번갈아가면서 수행**
→ 이 때 `한 부분에서 다른 작업의 부분으로 변경하는 행위`

## 4. 프로세스 생명 주기
### 프로세스 스케쥴링
- `프로세스 스케쥴링` : 멀티태스킹을 위해 프로세스의 우선순위, 작업량 등을 고려해 CPU를 효율적으로 사용함으로써 시스템 성능을 향상시킴
- `알고리즘 종류` : FCFS(First-Come First-Served), SJF(Shortest-Job-First), Priority, RR(Round-Robin), Multilevel Queue 등
### 프로세스 상태
| `프로세스 상태` | `설명` |
|:---:|:---:|
| 생성 (new) | 프로세스가 생성되고 아직 준비가 되지 않은 상태 |
| 준비 (ready) | 프로세스가 실행을 위해 기다리는 상태. CPU를 할당받을 수 있는 상태이며, 언제든지 실행될 준비가 됨 |
| 실행 (running) | 프로세스가 CPU를 할당받아 실행되는 상태 |
| 대기 (waiting) | 프로세스가 특정 이벤트(입출력 요청 등)가 발생하여 대기하는 상태.<br>CPU를 할당받지 못하며, 이벤트가 발생하여 다시 **ready** 상태로 전환될 때까지 대기 |
| 종료 (terminated) | 프로세스가 실행을 완료하고 종료된 상태. 더 이상 실행될 수 없으며, 메모리에서 제거됨 |
### 프로세스 상태 전이
![프로세스 상태 전이](https://blog.kakaocdn.net/dn/CixF9/btqUeiAiCDc/eTwjkrBKVnFhsNCAHYGw10/img.png)
- `Dispatch` : 준비 상태의 프로세스가 스케쥴러에 의해 실행됨
- `Interrupt` : Timeout, 예기치 않은 이벤트가 발생한 경우 실행 중인 프로세스를 준비 상태로 전환하고 해당 작업 먼저 처리
- `Block` : 실행 중인 프로세스를 대기 상태로 전환
- `Wakeup` : 처리해야 할 이벤트가 끝난 프로세스를 다시 준비 상태로 전환
### 프로세스 컨텍스트 스위칭
- `프로세스 컨텍스트 스위칭` : CPU 효율성을 높이기 위해, 한 프로세스에서 다른 프로세스로 전환할 때 발생하는 일련의 과정들.<br>
이 때, 컨텍스트 스위칭이 일어날 경우 다음 작업할 프로세스는 **스케쥴러**에 의해 결정됨
- `PCB(Process Control Block)` : 프로세스의 상태 정보를 담고 있는 자료 구조. Context Switching을 하므로 기존의 작업을 나중에 다시 불러와서 실행하기 위해서는 **작업 정보를 기억하고 있어야 한다**는 필요성에 의해 탄생
- `PCB의 생명` : Process의 생성 시 동시에 생성, 종료 시 삭제
- `PCB에 담기는 정보`
  - 포인터 : 프로세스의 현재 위치
  - 프로세스 상태 : 생성, 준비, 실행, 대기, 종료
  - 프로세스 ID : 프로세스의 고유 ID
  - 프로그램 카운터 : 프로세스를 위해 실행될 다음 명령어의 주소
  - 레지스터 : CPU 레지스터 정보
  - 메모리 제한 : 메모리 관리 시스템 정보
  - 열린 파일 목록 : 프로세스를 위해 열린 파일 목록
- `Context Switching 과정`<br>
ex) Process P1, P2에 대해 Context Switching
  1. CPU가 P1 Executing(실행)
  2. Interrupt or System call 발생
  3. CPU는 P1의 상태를 PCB1에 Save(저장)
  4. CPU는 스케쥴러에 의해 다음 실행할 프로세스로 P2 선택
  5. CPU는 P2의 상태를 PCB2에서 Reload(불러오기)
  6. CPU가 P2 Executing(실행)
  7. (...)
- **Context Switching Overhead**
  - 컨텍스트 스위칭 중 PCB의 저장 및 복원, (프로세스의 교체이므로) CPU의 캐시 메모리 초기화, 프로세스 스케쥴링 과정에서 **비용** 발생
  ![비용](https://i.stack.imgur.com/SDfzA.png)
## 5. 스레드 생명주기
### 스레드 스케쥴링
- `스레드 스케쥴링` : CPU에서, 다중 스레드를 관리하기 위해 여러 정보를 바탕으로 특정 스레드를 CPU에 할당하는 작업
- `알고리즘 종류` : Round Robin, Priority-based, Multi-level Queue 등
> 주의 : **하나의 프로세스 내에서 다수의 스레드가 동작하므로, 스레드 간 상호작용과 동기화 문제 고려 필수**
### 스레드 상태(Java 기준)
| `스레드 상태` | `설명` |
|:---:|:---:|
| NEW | 스레드가 생성되고 아직 호출되지 않은 상태 |
| RUNNABLE | 스레드가 실행을 위해 기다리는 상태. CPU를 할당받을 수 있는 상태이며, 언제든지 실행될 준비가 됨 |
| WAITING | 다른 스레드가 특정 작업을 수행하는 것을 기다리는 상태 |
| TIMED_WAITING | 지정된 대기시간동안 기다리는 상태 |
| BLOCKED | 스레드가 특정 이벤트(입출력 요청 등)가 발생하여 대기하는 상태.<br>CPU를 할당받지 못하며, 이벤트가 발생하여 다시 **RUNNABLE** 상태로 전환될 때까지 대기 |
| TERMINATED | 스레드가 실행을 완료하고 종료된 상태. 더 이상 실행될 수 없으며, 메모리에서 제거됨 |
- 프로세스 5가지 상태에서 실행(running) 상태가 빠짐
### 스레드 상태 전이(Java 기준)
![스레드 상태 전이](https://blog.kakaocdn.net/dn/Hskyu/btrpox1z8Wu/qqthvwdZIGUs2tjuR148p1/img.jpg)
- `yield()` : 현재 실행중인 스레드가 자신에게 할당된 작업시간을 양보함을 스케쥴러에게 통보
### 스레드 컨텍스트 스위칭
![스레드 컨텍스트 스위칭](https://images.velog.io/images/curiosity806/post/38289bd6-b2ed-46ba-81a6-36c5bc330dd4/image.png)
- `스레드 컨텍스트 스위칭` : 멀티 스레드 환경에서, 한 프로세스 내의 스레드 간 실행을 전환하는 기술
- `TCB(Thread Control Block)` : 스레드에 대한 정보를 담고 있는 자료 구조. TCB는 PCB 안에 존재, PCB와 TCB는 LinkedList로 연결
- `TCB의 특징` : 스레드 간 자원 공유 및 동기화 시 TCB를 통해 관리됨<br>
ex) mutex, semaphore 등의 동기화 사용 시 **TCB에서 해당 스레드의 동기화 정보를 관리**하며 스레드가 해당 자원에 대한 접근 권한 획득 or 반납 시 TCB 정보 업데이트

### 공유 자원 동기화 문제
- `임계영역(critical section)` : 공유 자원에 접근하는 프로세스 내부의 코드 영역, 이 영역에 한 프로세스가 사용 중일 때 다른 프로세스가 같은 영역 사용 시 문제 발생
- 임계 영역 문제 해결을 위한 3 조건
  - `상호 배제(Mutual Exclusion)` : 두 개 이상의 스레드(프로세스)가 공유 자원에 동시 접근하는 것을 막기 위해, 한 스레드(프로세스)가 공유 자원 사용 시 다른 스레드(프로세스)들은 사용하지 않도록 막음
  - `진행(Progress)` : 임계 영역에 들어간 스레드(프로세스)가 없는 상태에서 임계 영역에 들어가려는 스레드(프로세스)가 여러 개일 경우 어느 것이 들어갈지 결정해줘야 함
  - `한정 대기(Bounded Waiting)` : 기아 상태를 방지하기 위해, 스레드(프로세스)가 임계 영역에 들어가려고 요청한 후부터는 다른 스레드(프로세스)들이 임계 영역에 들어가는 횟수에 제한을 둠
- 해결 방안
  - `mutex(Mutual Exclusion)` : 공유 자원에 Key에 해당하는 오브젝트를 소유한 **1개의 스레드만** 접근 가능, **다른 프로세스 간 동기화**
  - `semaphore` : 공유 자원에 **여러 개의 스레드** 접근 가능, counter를 두어 허용 가능 스레드 수 제한, 소유 불가능
  - `monitor` : **하나의 프로세스 내에서 다른 스레드 간의 동기화**

### 컨텍스트 스위칭에서 프로세스와 스레드의 차이
|  | `프로세스 컨텍스트 스위칭` | `스레드 컨텍스트 스위칭` |
|:---:|:---:|:---:|
| 속도 | 느림 | 빠름(TCB는 stack 영역 정보만 저장) |
| 캐시 메모리 | 초기화됨<br>(CPU가 다른 프로세스의 명령어와 데이터를 로드해야 하므로) | 초기화되지 않음<br>(But 다른 CPU 코어에서 실행될 시 초기화될 수 있음) |
| 자원 동기화 | 기본적으로는 독립된 공간<br>(But IPC 등 공유 자원 사용 시 동기화 문제 발생) | 동기화 문제 발생 |
