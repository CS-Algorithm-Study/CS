# TCP란?

> 서버와 클라이언트간에 데이터를 신뢰성 있게 전달하기 위해 만들어진 프로토콜
> 

➕ UDP는 신뢰성을 보장하지 않는 프로토콜로 많이 알고 있는데 UDP 자체에서는 보장하지 않지만 개발자가 직접 신뢰성을 보장하도록 하면 신뢰성이 보장된다고 한다. 

**ex)** HTTP/3에서는 UDP기반의 QUIC이라는 프로토콜을 사용해서 신뢰성을 보장하도록 한다고 한다. (TCP의 Fast Retransmit, Selective Acknowledgement와 유사한 방식을 사용함)

<br>

# TCP에서 신뢰성을 보장하는 방법

## 1. 순서 보장

데이터 패킷에 순서 번호를 부여해서 수신자가 패킷을 올바른 순서대로 재조립할 수 있도록 한다. 

만약에 순서대로 도착하지 않는다면 누락된 패킷이 도착할 때까지 대기하고 그 후에 패킷을 재조립하여 애플리케이션에 전달한다.

<br>


## 2. 오류 제어 (오류 검출 및 재전송)

### ▪️ ARQ (Automatic Repeat Request)

TCP는 기본적으로 재전송 기반의 오류 제어를 사용하는데 실제로는 많은 데이터를 주고 받아야 하기 때문에 이런 재전송 방식은 비효율적일 수도 있다. 따라서 재전송을 최대한 적게 하는 방식으로 오류를 제어한다.

<br>

### ▪️ Stop and Wait ARQ
![stop and wait](https://github.com/CS-Algorithm-Study/CS/assets/48826098/6479f971-5c0c-4500-8981-d45bae44b614)


> 송신측에서 1개의 프레임을 송신하고 수신측에서 수신된 프레임의 에러 유무 판단에 다라 ACK 또는 NAK를 보내는 방식이다.
> 
- 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0, 1 번호를 번갈아가며 부여한다.
- 수신측이 데이터를 받지 못했을 경우, NAK를 보내고 NAK를 받은 송신측은 데이터를 재전송한다.
- 만약, 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다.

<br>

### ▪️ Go-Back-n ARQ (슬라이딩 윈도우)
![gbn](https://github.com/CS-Algorithm-Study/CS/assets/48826098/35ba5abd-d052-4fca-abaa-53a8fe73afd2)


> 패킷을 전송할 때 수신측에서 데이터를 잘못 받았거나 못 받았을 경우에 그 패킷 번호부터 다시 재전송을 하는 기법이다.
> 
- 슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송측은 전송된 프레임의 복사본을 가지고 있어야 하며 ACK와 NAK모두 각각 구별해야 한다.
    - ACK : 다음 프레임 전송
    - NAK : 손상된 프레임 자체 번호를 반환

<br>

### ▪️ SR(Selective-Repeat) ARQ
![sr](https://github.com/CS-Algorithm-Study/CS/assets/48826098/86468055-e310-41cb-90b5-f8a39d30f9fc)


> 수신측에게 오류가 발생된 수신 패킷만 다시 전송하기 때문에 불필요한 재전송을 피하는 기법이다.
> 
- GBN방식의 단점을 보완한 모습이라고 볼 수 있지만 실제로는 GBN 방식을 제일 많이 사용한다고 한다.
1. 수신측은 ACK의 순서에 상관없이 그냥 받은 패킷에 대한 ACK만 보낸다.
2. 송신측은 ACK를 받지 못한 모든 패킷에 대해 타이머를 계산하고 다시 보낸다.
- 윈도우 사이즈는 sequence number의 개수의 절반보다 이하여야한다. (중복된 패킷을 받게 되는 문제가 발생할 수도 있기 때문에)
    - 위 그림에서는 sequence number :  10, window size : 4

<br>

## 3. 혼잡제어

> 송신측의 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법이다. 
**네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것**이 혼잡제어의 개념이다.
> 

<br>

### ▪️ AIMD(Addtive Increase Multicative Decrease)

> 합 증가/곱 감소 알고리즘이라고 부르며 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기를 1씩 증가시키면서 전송하는 방법이다.
> 
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.

**문제점**

- 초기 네트워크의 높은 대역폭을 사용하지 못해서 오랜 시간이 걸리게 되고 네트워크가 혼잡해지는 상황을 미리 감지하지 못하여 혼잡해지고 나서야 대역폭을 줄이는 방식

<br>

### ▪️ Slow Start
![slow star](https://github.com/CS-Algorithm-Study/CS/assets/48826098/97f2d558-cbcd-4b9f-b619-1fc42c0744ea)


> AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK패킷마다 window size를 1씩 늘리는 방식. 즉, 한 주기가 지나면 window size가 2배가 된다.
> 
- AIMD에 비해 전송속도가 지수 함수 꼴로 증가한다. 대신에 혼잡현상이 발생하면 window size를 1로 떨어뜨리게 된다.
- 미리 정해진 임계값에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.
- 전송되는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다.

<br>

### ▪️ 혼잡회피
![혼잡회피](https://github.com/CS-Algorithm-Study/CS/assets/48826098/51557e57-540a-4ad0-bffe-3f81f5af56c5)


> window size가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높기 때문이 이를 회피하기 위해 윈도우 크기를 선형적으로 1씩 증가시키는 방법이다.
> 
- 전송하는 데이터의 증가를 왕복시간 동안에 하나씩만 증가시킨다.

<br>

### ▪️ 빠른회복

> 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법
이 정책까지 적용하면 혼잡 상황을 한 번 겪고 나서부터는 순수한 AIMD방식으로 동작한다.
> 

<br>

### ▪️ 빠른 재전송

> 수신측에 먼저 도착해햐할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보낸다. 중간에 패킷이 하나 손실되면 송신측에서는 순번이 중복된 ACK패킷을 받게된다. 이것을 감지하게 되면 문제가 되는 순번의 패킷을 재전송할 수 있다.
> 
- 중복된 패킷을 3개 받으면 (3 ACK) 재전송한다. 이런 현상이 일어나면 혼잡이 발생했다고 간주해서 window size를 절반으로 줄인다.



<br>
<br>

**reference**

https://land-turtler.tistory.com/154

[https://github.com/GimunLee/tech-refrigerator/blob/master/Network/흐름제어 %26 혼잡제어 %26 오류제어.md](https://github.com/GimunLee/tech-refrigerator/blob/master/Network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20%26%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4%20%26%20%EC%98%A4%EB%A5%98%EC%A0%9C%EC%96%B4.md)
