# 🔶 CPU 스케줄링이란?

> OS가 CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업
> 
- 프로세스들에게 자원을 최대한 공평하게 배분하며 처리율과 CPU 이용률을 증가시키고 오버헤드, 응답시간, 대기시간을 최소화하기 위한 기법

## 🔸 CPU 스케줄링 방식

**선점형 스케줄링**

- 프로세스가 CPU를 할당 받아 실행 중이더라도 운영체제가 이를 강제로 뺏을 수 있는 방식
- CPU 처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어 효율적인 운영이 가능
- 잦은 문맥 교환으로 오버헤드가 커질 수 있음

**비선점형 스케줄링**

- 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 없는 방식
- 필요한 문맥 교환만 일어나므로 오버헤드가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 남

**➕ 오버헤드란?**

프로그램 실행 흐름에서 나타나는 현상 중 하나이며 예를 들어, 프로그램의 실행 흐름 도중에 동떨어진 위치의 코드를 실행시켜야할 때 추가적으로 시간, 메모리, 자원이 사용되는 현상

예를 들어, 10초 걸리는 기능이 간접적인 원인으로 20초 걸리게 된다면 여기서 10초는 오버헤드가 되는 것

## 🔸CPU 스케줄링 평가방식

1. CPU 이용률
    - 시간당 CPU를 사용한 시간의 비율
    - 프로세스를 항상 실행상태로 유지하고 해야 함
2. 처리율
    - 시간당 처리한 작업의 비율
    - 단위 시간당 완료되는 작업 수가 많도록 해야 함
3. 반환시간
    - 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간
    - 프로세스의 대기시간 + 실행시간
4. 대기시간
    - 프로세스가 CPU를 할당받아 실행되기 전 대기 상태일 때의 시간
    - 준비 큐에서 기다린 시간의 총합
5. 반응 시간
    - 대기열에서 처음으로 CPU를 얻을 때까지 걸린 시간

👉 CPU 이용률와 처리율은 극대화하는 것이 좋고 반환시간, 대기시간, 반응시간은 줄이는 것이 음

## 🔸CPU 스케줄링 알고리즘

### 1. FCFS (First Come First Served) 스케줄링

- 가장 먼저 요청한 프로세스에 CPU를 할당해주는 방식
- 비선점형 스케줄링
- 평균 대기 시간이 길어질 수 있음
- 응답시간이 길어질 수 있음
- 반환시간면에서 좋지 않을 수도 있음
- 호위효과가 발생할 수 있음
    - 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것
![FCFS](https://github.com/CS-Algorithm-Study/CS/assets/48826098/4ec80e28-6d3e-46b8-b36d-accfd02703bd)


### 2. SJF(Shortest-Job-First)스케줄링

- 다음 CPU burst time의 길이를 고려해서 스케줄링을 결정하는 알고리즘
- 비선점형과 선점형 따로 존재
- 비선점형에서는 실행되고 있는 프로세스는 끝까지 실행
- 선점형에서는 현재 실행되고 있는 프로세스의 남은 시간보다 도착한 다음 프로세스가 더 빨리 끝날 수 있는 프로세스라면 다음 프로세스를 실행 → SRTF(Shortest Remaining Time First)라고 부름 → 하지만 다음 프로세스의 CPU burst time을 예측하는건 어렵다

![sjf](https://github.com/CS-Algorithm-Study/CS/assets/48826098/37dcdea0-8953-4dd4-8530-1a74c2d8b963)

비선점형 SJF

![srtf](https://github.com/CS-Algorithm-Study/CS/assets/48826098/2003f6f5-4ffe-4b10-88c6-f3893d89aa64)

선점형 SJF

### 3. Priority 스케줄링

- 각각의 프로세스에 우선순위가 있음
- 가장 높은 우선순위의 프로세스에 CPU 할당
- 선점형과 비선점형 존재
- SJF도 Priority스케줄링이라고 할 수 있음
- 기아문제가 발생할 수 있음 ( 낮은 우선순위의 프로세스가 실행되지 않는 문제)
- 기아문제를 해결하기 위해서는 노화를 사용할 수 있음 (시간이 지날수록 프로세스의 우선순위를 높여줌)

![priority](https://github.com/CS-Algorithm-Study/CS/assets/48826098/8064acad-f343-48c4-b8ed-f402fc0454d1)

### 4. RR(Round Robin) 스케줄링

- 각각의 프로세스에 동일한 CPU할당 시간을 부여해서 해당 시간 동안만 CPU이용
- 할당 시간 내에 처리를 완료하지 못하면 다음 프로세스로 넘어가므로 선점형 방식
- n개의 프로세스가 있을 때 할당 시간을 q로 설정하면 어떤 프로세스도 (n-1)q시간 이상을 기다리지 않아도 됨
- 응답 시간을 빠르게 할 수 있다는 장점
- q가 커진다면 FCFS처럼 작동
- q가 작아지면 process sharing이라고 부름 (n개의 프로세스가 프로세서 속도의 1/n씩으로 작동)

![rr](https://github.com/CS-Algorithm-Study/CS/assets/48826098/8c76822d-3560-4a1b-b6f2-73b0bfe8082b)

### 5. Multilevel Queue

- 준비 큐가 여러 개의 큐들로 나뉨
- 각 큐는 각자의 스케줄링 알고리즘을 가짐
- 각 큐 사이에서 프로세스들이 이동할 수 없음
- 일반적으로 foreground 프로세스는 RR방식을 사용하며 background 프로세스는 FCFS를 사용
- 기아문제 발생할 수 있음
- 보통 CPU 시간의 80%는 foreground의 RR, 20%는 background의 FCFS할당

![MUTILEVEL](https://github.com/CS-Algorithm-Study/CS/assets/48826098/d30742db-93fb-4a6e-8657-11a4f573478b)

### 6. Multilevel Feedback Queue(MFQ)

- Multilevel Queue와 비슷하지만 MFQ는 각 큐간에 프로세스들이 이동할 수 있음
![MFQ](https://github.com/CS-Algorithm-Study/CS/assets/48826098/94782972-45d1-4c77-af31-bb6d14aaddb7)
