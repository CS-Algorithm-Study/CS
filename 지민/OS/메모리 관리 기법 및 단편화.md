## 메모리 관리 기법

### 연속 메모리 기법

- 프로그램 전체가 메모리에 연속적으로 할당되어야 하는 관리 기법
- 고정 분할 기법: 메모리가 고정된 파티션(길이)로 분할
    - 필요한 용량보다 더 큰 메모리를 받으면 메모리 낭비
    - 내부 단편화 발생
- 동적 분할 기법: 파티션들이 동적으로 생성
    - 자신의 크기과 같은 파티션에 적재
    - 메모리를 적재/해제 반복하면서 외부 단편화 발생

### 불연속 메모리 기법

- 프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
- Page: 프로세스를 고정된 크기의 작은 블록들로 나눴을 때, 그 블록들을 페이지라 함
- Frame: 페이지 크기와 같은 주 기억장치 메모리 블록
- Segment: 서로 다른 크기의 논리적 단위

---

## 가상 메모리

- 가상 메모리란 실제 메모리 크기와 관계없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용하는 것을 뜻한다.
- 프로세스의 일부분만 메모리에 로드하고 나머지는 보조 기억 장치(가상 메모리 공간)에 로드한다.
- MMU를 통해 논리주소, 물리 주소를 나누어 사용하여 CPU를 속인다.
- MMU = 가상 주소를 실제 메모리 주소로 변환해주는 장치

**장점**

- 실제 메모리(RAM)보다 더 큰 공간을 사용
- 가상의 주소를 사용해 논리적인 연속성 제공
- 물리 메모리의 주소 공간을 몰라도 됨

---

## 메모리 단편화

- 컴퓨터에서 어떤 프로그램을 실행할 때, 메모리의 공간을 연속적인 형태로 할당하여 사용하게 된다.
- 프로그램이 메모리에 할당되고 해제되고, 다시 새로운 프로그램이 할당 및 해제되고를 반복하다보면 
RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 실제로는 사용가능한 메모리가 충분히 존재하지만 할당이 불가능한 상태가 발생하게 된다.

### 내부 단편화
![image](https://github.com/CS-Algorithm-Study/CS/assets/77067383/141a1aeb-dc80-48b2-b446-b918830aa018)

- 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황을 내부 단편화라고 함
- 그림처럼 메모리를 할당하는 최소 블록 크기를 10K라 했을 때 PROCESS A는 7K만 필요하므로 3K의 메모리가 낭비됨

### 외부 단편화
![image](https://github.com/CS-Algorithm-Study/CS/assets/77067383/b12a2930-2e56-4d60-997f-7e23bd7eb78a)

- 메모리가 할당되고 해제되는 작업이 반복적으로 일어날 때, 할당된 메모리와 메모리 사이에 사용하지 않는 작은 메모리가 생김
- 작은 메모리들의 합인 총 메모리 공간은 충분하지만 실제 할당가능한 공간은 부족하여 할당할 수 없는 상황을 말함
- PROCESS A, PROCESS B, PROCESS C를 할당하면서 중간에 3K, 1K, 5K 같은 작은 메모리 공간이 생김
총 남은 메모리는 8K이기 때문에 PROCESS D를 할당할 수 있어야 하지만 분할하여 할당할 수없으므로 PROCESS D를 할당할 수 없음

---

## 단편화 해결 방법

1. 페이징 기법: 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재
- 가상메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 하고 RAM을 페이지와 같은 크기의 블록으로 나눈 것을 프레임이라고 한다.
- 페이징 기법이란 사용하지 않는 프레임을 페이지로 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 방법을 말한다.
- 페이지와 프레임을 대응시키기 위해 page mapping 과정이 필요해서 paging table을 만든다.
- 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.
- 그러나 페이지 단위를 작게하면 외부 단편화 문제를 해결할 수 있지만 그 대신 page mapping 과정이 많아져 효율이 떨어지게 된다.

![image](https://github.com/CS-Algorithm-Study/CS/assets/77067383/27733c3a-4a14-4905-94f3-8ac60a53b8af)

2. 세그멘테이션 기법: 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재
- 페이징 기법에서 가상 메로리를 같은 크기의 단위로 분할했지만 세그멘테이션 기법에서는 가상 메모리를 서로 크기가 다른 논리적 단위의 세그먼트로 분할한 후 메모리를 할당하여 실제 메모리 주소로 변환을 하게 된다.
- 각 세그먼트는 연속적인 공간에 저장되더 있다.
- 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
- 페이징 기법과 마찬가지로 mapping을 위해 세그먼트 테이블이 필요하다.
- 프로세스가 필요한 메모리만큼 할당해주기 때문에 내부 단편화는 일어나지 않으나 여전히 중간에 프로세스가 메모리를 해제하면 생기는 틈, 즉 외부 단편화 문제는 해결되지 못한다.

![image](https://github.com/CS-Algorithm-Study/CS/assets/77067383/81b96b55-3e74-4c6c-8418-d3f08ee6b55b)

3. 메모리 풀 기법
- 필요한 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하며 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법이다.
- 메모리 풀없이 동적 할당과 해제를 반복하면 메모리의 특정 위치에 할당과 해제가 반복되면서 단편화를 일으킬 수 있겠지만 미리 공간을 할당해놓은 후에 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다.
- 또한 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.
- 하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 사용하지 않아야 한다.
- 메모리의 할당, 해제가 잦은 경우 메모리 풀을 쓰면 효과적이다.
- 미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식이다.

[출처](https://velog.io/@tlsdnxkr/CS-%EB%8B%A8%ED%8E%B8%ED%99%94-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-%ED%8E%98%EC%9D%B4%EC%A7%95%EB%82%B4%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94-%EC%99%B8%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94)
