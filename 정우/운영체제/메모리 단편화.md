# 🧩 메모리 단편화

## 목차
### 1. 메모리 단편화란?
### 2. 내부 단편화
### 3. 외부 단편화
### 4. 메모리 단편화 해결방법

</br>

## 🤔 메모리 단편화란?

- **사용 가능한 메모리 자체는 충분하지만 메모리의 공간이 작은 조각으로 나뉘어져 할당이 불가능한 상태를 말한다**
  
- 사용 가능한 자원이 충분함에도 이를 사용하지 못하므로 **자원 낭비를 초래하게 된다**
  
- 메모리 단편화는 **`내부 단편화`** 와 **`외부 단편화`** 로 구분 가능하다

</br>

## 🤔 내부 단편화

- **메모리를 할당할 때 프로세스 필요한 메모리보다 더 큰 메모리가 할당되어, 할당된 메모리 내부에서 발생하는 단편화를 말한다**

- 프로세스는 실제로 사용하지 않는 메모리 공간을 계속 가지게 되고, 메모리 공간 낭비가 발생하게 된다  

- 예를 들어, **`100MB`** 의 메모리에 **`80MB`** 크기의 프로세스를 적재하면, 다음과 같이 **`20MB`** 의 내부 단편화가 발생한다

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/0b81aa78-f9aa-4e19-8248-66b9019c4e53)


</br>

## 🤔 외부 단편화

- **메모리가 할당되고 해제되는 작업이 반복되면서 할당되는 메모리 사이에 작은 메모리가 중간중간 존재하게 된다**
  
- **이런 작은 메모리가 쌓이면서 총 메모리 공간은 충분하지만 불연속적으로 존재하는 메모리로 인해 발생하는 단편화를 외부 단편화라고 한다**
  
- 예를 들어 아래와 같은 상황일 때, 사용 가능한 총 공간은 **`100MB`** 지만, 외부 단편화로 인해 **`80MB`** 메모리가 필요한 프로세스에게 메모리를 할당해줄 수 없다

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/b8296aff-a470-4c81-9215-e67c7cfb13ed)

</br>

## 🧐 메모리 단편화 해결방법

### 1. 압축 (외부 단편화를 해결)

- 메모리 재배치를 통해 단편화 되어 있는 공간들을 하나로 합치는 방법이다
  
- **전체 메모리를 재배치한다**
  
![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/134ae533-9598-4bff-be17-2c3fcf10b185)

<br>

### 2. 통합 (외부 단편화를 해결)

- 단편화된 메모리 공간들 중에 인접해 있는 공간끼리 통합시키는 방법이다
  
- **전체 메모리를 재배치를 하는 것이 아니기 때문에 성능 상 압축보다 통합이 유리할 수 있다**

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/5484e27b-bfa4-4eab-a63d-1ee75dc6bda8)

<br>

### 3. 페이징 (외부 단편화를 해결)

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/91676e12-0c29-4323-81e2-c5b76137f6ca)


- 프로세스의 가상 메모리를 고정된 크기의 **`Page`** 단위로 나누어 물리적 메모리에 **불연속적으로 할당**하는 방식이다
  
- 메모리는 **`Frame`** 이라는 고정 크기로 분할되고, 프로세스는 **`Page`** 라는 고정 크기로 분할되며 **Page와 Frame의 크기는 같다**

- 페이지와 프레임을 대응시키는 **`Page Mapping`** 과정이 필요하기 때문에 **`Paging Table`** 을 생성해야 한다

- 페이지 테이블에는 각 **`페이지 번호`** 와 해당 페이지가 할당된 **`프레임의 시작 물리 주소`** 를 저장

- 할당은 항상 프레임(=페이지)의 **정수 배**로 할당되는데, 프로세스에서 요구하는 메모리의 크기가 페이지의 배수가 아닐 경우 마지막 페이지에 내부 단편화가 발생하고 페이지의 크기가 클수록 내부 단편화가 커진다

- 페이지 단위를 작게 하면 내부 단편화 문제도 거의 해결할 수 있지만, **Page Mapping 과정이 많아져 효율이 좋지 않다**

<br>

### 4. 세그멘테이션 (내부 단편화를 해결)

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/2c9836fd-3cdd-4af0-96fe-9605f1025b8a)


- 프로세스의 가상 메모리를 서로 다른 크기가 다른 논리적인 블록 단위인 **`Segment`** 로 나누어 물리적 메모리에 할당하는 방식이다
  
- 각 세그먼트는 **연속적인 공간에 저장**된다

- 세그먼트들의 크기가 서로 다르기 때문에 **프로세스가 메모리에 적재될 때** 적절한 빈 공간을 찾는다

- 페이징과 마찬가지로 **`Mapping`** 을 위한 **`Segment Table`** 이 필요하다

- 세그먼트 테이블에는 각 세그먼트의 **`시작 물리 주소`** 와 **`세그먼트의 길이`** 를 저장

- 프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생하지 않지만, 여전히 중간에 위치한 프로세스가 메모리를 해제하면 **외부 단편화 문제가 발생한다**

<br>

### 5. 메모리 풀 (내부, 외부 단편화를 해결)

- 메모리 공간을 **`필요한 크기`** , **`개수`** 만큼 **사용자가 직접 지정하여 미리 할당 받아 놓고, 필요할 때마다 사용하고 반납하는 방식이다**

- 메모리 풀을 사용하게 되면 **미리 공간이 할당되어 있는 상황에서 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다**

- 또한 **필요한 크기만큼 할당을 해놓기 떄문에 내부 단편화 또한 발생하지 않는다**

- 하지만, 메모리를 사용하지 않는 순간에도 계속 할당되어 있기 때문에 메모리 누수가 발생한다

- 따라서 **`메모리 단편화로 인한 메모리 낭비량`** 보다 **`메모리 풀을 만들어 할당해놓고 쓰지 않았을 때의 메모리 낭비량`** 이 더 커지면 사용하지 말아야 한다

