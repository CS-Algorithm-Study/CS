# 📲 가상 메모리
## 목차
### 1. 가상 메모리란?
### 2. 가상 메모리 배경 지식과 이점
</br>

## 🤔 가상 메모리란?

</br>

메모리 관리 기법중 하나로 **프로세스 전체가 메모리 내에 올라오지 않더라도** 실행이 가능하도록 하는 기법

- 사용자 프로그램이 **물리 메모리의 제약에서 벗어남**
- 각 프로그램이 **더 작은 메모리를 차지**하기 때문에 더 많은 프로그램을 동시수행 가능

</br>


## 🤔 가상 메모리 배경 지식과 이점

</br>

### 구조

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/bd8c5c80-a3c8-418e-995e-545a9548f84b)

- 프로그램 실행시키기 위해 CPU의 연산이 필요하다
- CPU는 레지스터를 통해 연산을 하지만 용량이 작기 때문에 메모리 값을 참조하여 연산을 한다
- CPU의 레지스터와 메모리는 빠르지만 휘발성이고, 디스크는 느리지만 비휘발성이다

</br>
<hr>

### 파일 실행

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/a174b042-4696-42f9-a733-949867f9612b)

- CPU는 디스크의 값을 참조할 수 없기 때문에 메모리에 올려 이 값을 참조한다
- 디스크에서 메모리로 실행파일을 올리기 위해 fork()로 프로세스를 생성하고, exec()으로 로더를 호출하여 이진실행파일을 메모리에 올린다

</br>
<hr>

### 주소 바인딩

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/acc9f1a7-e022-474d-9785-5c36b27fac0e)

- 논리 주소는 **CPU가 프로세스마다 생성하는 주소**이고, 물리 주소는 **실제 메모리의 주소**이다
- 논리 주소 공간은 **각 프로세스 마다 주어지는 논리 공간**으로, 메모리 크기와는 독립적이고 레지스터 크기에 종속적이다

</br>
<hr>

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/327056a6-df4e-4acf-a1a0-1218e8bab64a)

- MMU 레지스터는 프로세스의 실제 메모리 주소의 시작 지점
- **CPU가 생성한 논리적 주소 + MMU 의 주소 값**

### 스왑영역

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/b20dac99-77af-4057-ae49-47e9a6996f16)

- 메모리 공간이 부족할 때 사용되는 공간으로 **외부저장장치에 존재** (메모리 확장개념)
- 메모리와 스왑 영역간의 이동은 Swap out, Swap in
- **프로세스가 실행하는 동안에만 일시적으로 사용**되고, 공간 효율성보다 시간 효율성이 우선시 되기 때문에 파일 시스템보다는 접근이 빠르다
</br>
<hr>

### 가상 메모리

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/158c3759-9913-4872-a0d1-1b7506d5e95b)

- 프로세스의 전체 내용을 메모리에 올리지 않고 **필요한 내용만 메모리에 올려서 사용**
- 요구 페이징 기법을 사용

</br>
<hr>

### 이점

- 사용자 프로그램이 **물리 메모리의 제약에서 벗어남**
  - 사용자의 프로그램이 물리 메모리보다 커져도 됨
  - 프로그래머는 물리 메모리 크기를 신경쓰지 않아도 되기 때문에 **실제 해결하고자 하는 문제에 집중가능**
  
- 각 프로그램이 **더 작은 메모리를 차지**하기 때문에 더 많은 프로그램을 동시수행 가능
  - 프로세스 당 메모리 사용량이 감소하고, **더 많은 프로세스를 수용** 가능
  
