# 🔖 트랜잭션(Transaction)

## 목차 
### 1. 트랜잭션의 개념
### 2. ACID
### 3. 트랜잭션 격리 수준
### 4. Lock
</br>

## 🤔 트랜잭션이란?

- **트랜잭션을 직역하면 거래라는 뜻으로, 데이터베이스에서 하나의 동작(거래)을 안전하게 처리하도록 보장해주는 것을 말한다**

</br>

예를 들어, A가 B에게 10000원을 계좌이체 한다고 했을 때, 

1. A의 잔고를 10000원 **`감소`**
2. B의 잔고를 10000원 **`증가`**

이 두 개의 작업이 동시에 이루어져 **하나의 작업처럼 동작**해야 한다.

**만약 1번 작업만 성공하고 2번 작업이 실패한다면, A의 잔고만 줄어드는 치명적인 문제가 발생한다.**

데이터베이스가 제공하는 트랜잭션 기능을 사용하면 1, 2번 작업이 모두 성공할 경우에만 저장하고, 하나라도 실패한다면 거래 전의 상태로 돌아갈 수 있다.

- 모든 작업이 성공해서 데이터베이스에 정상 반영되는 것을 **`커밋(Commit)`**
- 작업 중 하나라도 실패하여 거래 이전으로 되돌리는 것을 **`롤백(Rollback)`**
  

#### 👉 데이터베이스가 트랜잭션이라는 개념을 지원하기 때문에 데이터를 저장할 때 일반 파일에 저장하는 것이 아닌 데이터베이스에 저장하는 것이다.

</br>

## 🧐 ACID

- 트랜잭션은 ACID라고 하는 **`원자성(Atomicity)`, `일관성(Consistency)`, `격리성(Isolation)`, `지속성(Durability)`** 를 보장해야 한다.

- **원자성(Atomicity) :** 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
- **일관성(Consistency) :** 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
- **격리성(Isolation) :** 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준을 선택할 수 있다.
- **지속성(Durability) :** 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

트랜잭션은 **`원자성`, `일관성`, `지속성`** 을 보장한다. 반면 트랜잭션 간에 **`격리성`** 을 완벽하게 보장하려면 트랙잭션을 거의 순서대로 실행해야 하는데,  이는 동시 성능 처리가 매우 나빠지게 한다. 
이런 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.

</br>

## 😵 트랜잭션 격리 수준
복수개의 트랜잭션이 한번에 처리될 때, 특정 트랜잭션이 **변경하거나 조회하고 있는 데이터에 대해** 다른 트랜잭션이 조회를 허용하게 할 지 여부를 결정하는 것이다.
트랜잭션 격리 수준은 4단계로 구분된다

- **SERIALIZABLE (직렬화 가능)**
- **REPEATABLE READ (반복 가능한 읽기)**
- **READ COMMITTED (커밋된 읽기)**
- **READ UNCOMITTED (커밋되지 않은 읽기)**

밑으로 갈수록 격리 수준은 낮아지고, 동시 처리 성능은 높아진다. 반면 위로 갈수록 격리 수준은 높아지고, 동시 처리 성능은 낮아진다.

**즉, 데이터 정합성과 성능은 반비례한다.**

</br>


### 트랜잭션 격리 수준에 따라 발생할 수 있는 문제점
👉 트랜잭션 격리 수준에 대한 설명에 앞서, **격리 수준에 따라 발생할 수 있는 문제점**을 간단히 설명!

</br>

#### 1. 더티 리드(Dirty Read)

더티 리드는 **특정 트랜잭션에 의해 데이터가 변경되었지만, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 해당 변경 사항을 조회할 수 있는 문제**를 말한다.
예를 들어, A가 B에게 10000원을 계좌이체 한다고 하자.
- A가 B에게 10000원을 계좌이체 하고 있다. **(트랜잭션1 - 커밋 전)**
- B의 잔고는 10000원이 증가한 상태이고 아직 커밋되지 않았다. **(트랜잭션1 - 커밋 전)**
- B가 잔고에 있는 돈(기존 잔고 + 10000원)을 모두 인출했다.  **(트랜잭션2 - 커밋 완료)**
- 트랜잭션1이 실패하여 **롤백**되었다. **(트랜잭션1 - 롤백)**

이렇게 됐을 때, B는 10000원이 입금 완료 되지 않았지만 10000원이 늘어난 잔고의 금액을 모두 인출할 수 있는 치명적인 문제가 발생한다. 
이 문제를 **`더티 리드`** 라고 한다.

</br>

#### 2. 반복 불가능한 조회 (Non-Repeatable Read)
같은 트랜잭션 내에서 같은 데이터를 여러 번 조회했을 때 읽어온 데이터가 다른 경우를 의미한다.

</br>

#### 3. 팬텀 리드 (Phantom Read)
Non-Repeatable Read의 한 종류로 조회해온 결과의 행이 새로 생기거나 없어지는 현상이다.

</br>

### SERIALIZABLE
특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다.
가장 높은 데이터 정합성을 가지나, 성능은 가장 떨어진다. 이 격리 수준에서는 단순한 SELECT 쿼리가 실행되더라도, 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없게된다.
</br>
</br> 👉**어떤 데이터를 조회하는데 1분 걸린다면, 그 데이터의 테이블은 1분간 사용할 수 없게됨.**

</br>

### REPEATABLE READ 
특정 행을 조회시 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준이다. 하지만, SERIALIZABLE과는 다르게 행이 추가되는 것을 막지 않는다. 이로 인해 팬텀 리드 현상이 발생할 수 있다.
![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/60548ca4-3293-4a28-b39a-ce01364df5b7)

</br>

### READ COMMITTED
커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용하는 격리 수준이다. </br>

👉 **진행중인 트랜잭션의 데이터를 다른 트랜잭션이 접근(변경)할 수 없다.**

특정 트랜잭션에서 데이터 변경이 이루어졌으나, 아직 커밋되지 않은 상태라면 다른 트랜잭션에서는 해당 데이터를 접근했을 때, 트랜잭션 시작 전의 데이터를 읽어온다. 커밋이 완료되면 변경된 데이터 값을 읽어올 수 있다. </br>

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/6652a93f-8bad-4039-a423-a96236ecce93)

**같은 트랜잭션 내에서**
- 데이터가 달라질 수 있으므로 **`반복 불가능한 조회`** 가 발생
- 데이터가 추가될 수 있으므로 **`팬텀 리드`** 가 발생

### READ UNCOMMITTED
커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용하는 격리 수준이다. 데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다. 

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/0658703e-87d9-4be4-8f22-3ae82a191c54)

더티 리드에서 설명했던 것처럼 **롤백** 시에 큰 문제가 발생할 수 있다.

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/cd96f6f5-d495-4adb-b6c6-57b695851269)

**같은 트랜잭션 내에서**
- 커밋되지 않은 데이터 변경 내용을 조회할 수 있으므로 **`더티 리드`** 가 발생
- 데이터가 달라질 수 있으므로 **`반복 불가능한 조회`** 가 발생
- 데이터가 추가될 수 있으므로 **`팬텀 리드`** 가 발생

</br>

## 😵 Lock
**락이란 트랜잭션 처리의 순차성을 보장하기 위한 방법**이다.

### Lock의 종류

#### 공유(Shared) Lock
- 공유 Lock은 데이터를 읽을 때 사용되어지는 Lock이다.
- **공유 Lock은 공유 Lock끼리는 동시에 접근이 가능**하다.
- 즉, 하나의 데이터를 읽는 것을 여러 사용자가 동시에 할 수 있다.
- 하지만 공유 Lock이 설정된 데이터에 베타 Lock은 사용할 수 없다.

#### 베타(Exclusive) Lock
- **베타 Lock은 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지**된다. 
- 베타 Lock은 Lock이 해제될 때까지 다른 트랜잭션 **(읽기 포함)** 은 해당 리소스에 접근할 수 없다. 
- 또한 베타 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없다.

</br>

### Lock의 설정 범위(Level)
- **데이터베이스**
  - 데이터베이스 범위의 lock은 전체 데이터베이스를 기준으로 lock함
  - 즉, 1개의 세션만 DB에 접근이 가능
  - 일반적으로 사용하지 않고, DB의 소프트웨어 버전을 올리거나 주요한 DB 업데이트에 사용

- **파일**
  - 데이터베이스 파일을 기준으로 lock을 설정
  - 파일이란 테이블, row 등과 같은 실제 데이터가 쓰여지는 물리적인 저장소를 말함

- **테이블**
  - 테이블을 기준으로 lock을 설정
  - 테이블의 모든 행을 업데이트 하는 등의 전체 테이블의 영향을 주는 변경을 수행할 때 유용함
  - DDL(create, alter, drop 등) 구문과 함께 사용되며 DDL Lock이라고도 함

- **컬럼**
  - 컬럼 기준의 lock은 컬럼을 기준으로 lock을 설정
  - lock 설정 및 해제 리소스가 많이 들기 때문에 일반적으로 사용하지 않음

- **행(Row)**
  - 행 수준의 lock은 1개의 행을 기준으로 lock을 설정
  - DML에 대한 lock으로 가장 일반적으로 사용하는 lock임

</br>

### 블로킹(Blocking)
**블로킹은 lock간(`베타`-`베타`, `베타`-`공유`) 의 경합이 발생하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춘 상태를 말한다.**
공유락 끼리는 블로킹이 발생하지 않지만 베타락은 블로킹을 발생시킨다. 블로킹을 해소하기 위해서는 이전의 트랜잭션이 완료(커밋 or 롤백)되어야 한다.
뒤에 들어온 트랜잭션은 이전 트랜잭션이 마무리되어야 이후 진행이 가능하고, 이런 경합은 성능에 안좋은 영향을 미치므로 최소화 해야한다.

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/ac0b6b31-c466-462b-a6ad-f4b4fc9ebc85)

</br>

#### DB를 사용할 때 주의사항
- 한 트랜잭션의 길이를 너무 길게하는 것은 경합의 확률을 올림
- 처음부터 설계할 때, 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 해야함
- 트랜잭션 격리 수준을 불필요하게 상향 조정하지 않아야함
- 쿼리를 오랜시간 잡아두지 않도록 적절할 튜닝을 진행

</br>

### 교착상태(DeadLock)
교착상태는 두 트랜잭션이 각각 lock을 설정하고 서로의 lock에 접근하여 값을 얻어오려고 할 때, </br>
**이미 각각의 트랜잭션에 의해 lock이 설정되어 있기 때문에 양쪽 트랜잭션 모두 영원히 처리되지 않는 상태**를 말한다.

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/dad5fc6b-f590-40f4-a3cf-046871f1324d)

- 교착상태가 발생하면 DBMS가 둘 중 한 트랜잭션에 에러를 발생시킴으로써 문제를 해결
- 교착상태가 발생할 가능성을 줄이기 위해서는 접근 순서를 동일하게 하는 것이 중요함
