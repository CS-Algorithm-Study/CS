# 트랜잭션 전파 속성

## 목차 
### 1. 트랜잭션 전파 속성(Transcation Propagation) 이란?
### 2. 물리 트랜잭션과 논리 트랜잭션
### 3. 스프링의 트랜잭션 전파 속성

</br>

## 🤔 트랜잭션 전파 속성이란

- 트랜잭션 전파 속성이란 **트랜잭션이 이미 진행중일 때, 추가 트랜잭션 진행을 어떻게 할지 결정하는 것이 트랜잭션 전파 속성**이다
- 전파 속성에 따라 기존의 트랜잭션에 참여하거나 별도의 트랜잭션으로 진행할 수도 있고 에러를 발생시키는 등 다양한 속성이 존재한다
- 스프링이 제공하는 선언적 트랜잭션(@Transcational)의 장점 중 하나는 여러 트랜잭션을 묶어서 커다란 하나의 트랜잭션 경계를 만들 수 있다는 점이다

<br>

**_트랜잭션이 다른 트랜잭션을 만나는 상황_**

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/6686e8e4-4a38-4dae-a6dc-09ceb6cb3913)


## 물리 트랜잭션과 논리 트랜잭션

<br>

**물리 트랜잭션**
- 트랜잭션은 데이터베이스에서 제공하는 기술이므로 **커넥션 객체를 통해 처리**한다
- 1개의 트랜잭션을 사용한다는 것은 하나의 커넥션 객체를 사용한다는 것이고, **실제 데이터베이스의 트랜잭션을 사용한다는 점에서 물리 트랜잭션**이라고 한다

<br>

**논리 트랜잭션**
- 트랜잭션 전파 속성에 따라 외부 트랜잭션과 내부 트랜잭션이 동일한 트랜잭션을 사용할 수 있다고 했다. 하지만 스프링 입장에서는 트랜잭션 매니저를 통해 트랜잭션을 처리하는 곳이 2군데이다
- 따라서 **실제 데이터베이스와 스프링이 처리하는 트랜잭션 영역을 구분**하기 위해 스프링은 **논리 트랜잭션**이라는 개념을 추가했다

<br>

- 물리 트랜잭션: 실제 데이터베이스에서 적용되는 트랜잭션으로, 커넥션을 통해 커밋/롤백하는 단위
- 논리 트랜잭션: 스프링이 트랜잭션 매니저를 통해 트랜잭션을 처리하는 단위

</br>

**_외부 트랜잭션과 내부 트랜잭션이 1개의 물리 트랜잭션(커넥션)을 사용하는 경우_**

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/2bc101c9-1799-41a7-9007-0c1154f1dad2)

</br>

- 2개의 트랜잭션 범위가 존재하기 때문에 개별 논리 트랜잭션이 존재하지만, 실제로는 1개의 물리 트랜잭션이 사용된다.

- 기존의 트랜잭션이 진행중일 때 또 다른 트랜잭션이 사용되면 복잡한 상황이 발생하지만, 스프링은 논리 트랜잭션이라는 개념을 도입함으로써 상황에 대한 설명을 쉽게 만들고, 다음과 같은 단순한 원칙을 세울 수 있었다.
  - **모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋**
  - **하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백**
  - **신규 트랜잭션만이 물리 트랜잭션을 종료(커밋/롤백)할 수 있다**
<br>

## 스프링의 트랜잭션 전파 속성

- 스프링에는 7가지 전파 속성이 존재하는데, **REQUIRED와 REQUIRES_NEW**를 이해하면 나머지는 응용이 가능하므로 두 가지 케이스에 대해 자세히 설명한다

<br>

### REQUIRED
- **REQUIRED**는 스프링이 제공하는 기본적인(DEFAULT) 전파 속성이다
- 예를 들면, 2개의 논리 트랜잭션을 묶어 1개의 물리 트랜잭션을 사용하는 것이다
- 내부 트랜잭션이 기존에 존재하는 외부 트랜잭션에 참여한다

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/092ac75a-bc23-44d2-a4c2-0b4ea4e129a3)

- 여기서 한가지 문제점은 1개의 논리 트랜잭션이라도 실패하면 물리 트랜잭션이 롤백된다는 점이다
  
<br>

**_문제 상황_**

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/b083f755-9aec-44db-960b-80ed4cb78ac3)

- 다음과 같이 핵심 비즈니스 로직인 영화 예매 로직과 로그 저장 로직이 같은 물리 트랜잭션 내에 있다고 해보자
- 만약 모두 성공한다면 문제 없이 잘 실행되겠지만, 영화 예매 로직은 잘 실행되었으나 로그 저장에 문제가 생겨 모두 롤백이 된다면?
- 사용자 입장에서는 로그 저장이 뭔지, 왜 예매가 안되는 지 이해가 안될 것이다
- 그렇다면 로그 저장에 실패해도 영화 예매는 유지되도록 하려면? **REQUIRES_NEW 속성을 사용하면 된다**

<br>

### REQUIRES_NEW
- **REQUIRES_NEW**는 외부 트랜잭션과 내부 트랜잭션을 완전히 분리하는 전파 속성이다
- 따라서 2개의 트랜잭션이 있다면 2개의 물리 트랜잭션이 사용되며 트랜잭션 별로 각각 커밋과 롤백이 수행된다

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/6927adfb-921c-4f66-a436-41953265c63c)

- 두 개의 서로 다른 물리 트랜잭션이므로, 내부 트랜잭션이 외부 트랜잭션 롤백에 영향을 주지 않는다

<br>

**_문제 상황 해결_**

![image](https://github.com/CS-Algorithm-Study/CS/assets/81271328/3b5b9e6b-a633-4ebd-b69c-e23b267b96b5)

- 로그 저장이 실패한다면 해당 트랜잭션은 롤백이 되지만, 영화 예매 트랜잭션에는 영향을 끼치지 않는다
- 따라서 로그 저장이 실패하더라도 영화 예매는 정상적으로 동작한다

<br>

**_REQUIRES_NEW 사용 시 주의해야 할 사항_**
- REQUIRES_NEW는 물리 트랜잭션을 별도로 가지기 때문에 각각의 디비 커넥션이 사용된다. 따라서 1개의 HTTP 요청에 대해 2개의 커넥션이 사용될 수 있으므로 이를 고려해서 사용해야 한다
- 또한 내부 트랜잭션이 처리 중일때, 외부 트랜잭션은 대기하게 되는데 이는 데이터베이스 커넥션을 고갈시킬 수 있기 때문에 조심해서 사용해야 한다

